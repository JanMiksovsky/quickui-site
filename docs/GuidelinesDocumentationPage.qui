<Control name="GuidelinesDocumentationPage">
<prototype>
<DocumentationPage title="QuickUI control class guidelines">

<h2>Modularity</h2>
<ul>
    <li>
        Each control should have a clear task or responsibility that can be succinctly stated.
    </li>
    <li>
        Design controls to be as context-independent as possible. The control’s host should not need to expose specific properties or handle specific events in order for the control to work.
    </li>
    <li>
        In general, a control should directly manipulate only the elements which it, itself, has added to the DOM (typically, by defining elements in the class’ content or prototype).
    </li>
    <li>
        As a corollary to the above point, a control should expose information to outside consumers via property setters and other methods, rather than expecting them to directly manipulate the control’s own contents.
    </li>
    <li>
        It should generally be possible to set properties in any order. If a control has two properties that work in tandem, have the side-effect function for each invoke a “private” function that checks to see if both are set before doing its work.
    </li>
    <li>
        Provide reasonable defaults. If someone instantiates the control as a standalone tag like <Tag>MyControl</Tag>, they should get some reasonably interesting default behavior.
    </li>
    <li>
        Avoid requiring that a control must have properties set on it.
    </li>
    <li>
         Law of Demeter
    </li>
    <li>
        Controls should avoid manipulating global variables.
    </li>
</ul>

<h2>Subclassing</h2>
<ul>
    <li>
        A control may call “private” methods (indicated with an “_” underscore) in its parent classes.
    </li>
    <li>
        If a control overrides a superclass method (including initialize), the method should generally invoke the same method in the superclass’ prototype.
    </li>
    <li>
        Use the MyControl.prototype.extend({...}) to define control instance behavior.
    </li>
    <li>
        Use MyControl.extend({...}) to extend class behavior (e.g., enums shared by all instances of a class).
    </li>
    <li>
        The script tag for a control should generally define the control class’ prototype and class. Avoid other side-effects.
    </li>
    <li>
        General-purpose controls should work with general-purpose data structures.
    </li>
</ul>

<h2>Coding conventions</h2>
<ul>
    <li>
        Derive from standard base classes when appropriate.
    </li>
    <li>
        Follow the jQuery Core Style Guidelines.
    </li>
</ul>

<h2>Naming conventions</h2>
<ul>
    <li>
        Classes and properties should have meaningful names in PascalCase (for classes) and camelCase (for properties). Generally avoid abbreviations.
    </li>
    <li>
        In closures, the variable to capture “this” is called “self”.
    </li>
    <li>
        Indicate "private" methods which control consumers should <i>not</i> call directly
        by prefixing their name with an underscore "_".
    </li>
    <li>
        To avoid confusion and guarantee cross-language interoperation, follow these rules regarding the use of abbreviations:
    </li>
    <li>
        Do not use abbreviations or contractions as parts of identifier names. For example, use GetWindow instead of GetWin.
    </li>
    <li>
        Do not use acronyms that are not generally accepted in the computing field.
    </li>
    <li>
        Where appropriate, use well-known acronyms to replace lengthy phrase names. For example, use UI for User Interface and OLAP for On-line Analytical Processing.
    </li>
    <li>
        When using acronyms, use Pascal case or camel case for acronyms more than two characters long. For example, use HtmlButton or htmlButton. However, you should capitalize acronyms that consist of only two characters, such as System.IO instead of System.Io.
    </li>
    <li>
        Do not use abbreviations in identifiers or parameter names. If you must use abbreviations, use camel case for abbreviations that consist of more than two characters, even if this contradicts the standard abbreviation of the word.
    </li>
</ul>

<h2>Styling</h2>
<ul>
    <li>
        When necessary, a control can define style rules that adjust the appearance of elements added by its parent classes.
    </li>
    <li>
        General-purpose base classes should avoid defining styles for aesthetic purposes. If a base class wishes to provide a bare-bones UI (so that, e.g., control elements are legible and can be seen), the control should define style rules that apply when the CSS class “basic” has been applied to a control instance.
    </li>
</ul>

<h2>Properties</h2>
<ul>
    <li>
        As a general rule, values which are set on a control via a function should be retrievable by calling the same function as a getter.
    </li>
    <li>
        If someone will be likely to want to set a property through markup, support the ability to set a property as a string. Use the specific property constructors like Control.property.bool().
    </li>
    <li>
        If you want to set complex defaults in initialize(), remember that the initialize() call happens after per-instance properties have been set. The initialize handler should generally only set a property to its default value if the property hasn’t already been set.
    </li>
</ul>

</DocumentationPage>
</prototype>
</Control>