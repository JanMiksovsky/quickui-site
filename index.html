<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<link rel="stylesheet" type="text/css" href="/release/quickui.css" />
<link rel="stylesheet" type="text/css" href="/release/quickui.catalog.css" />
<link rel="stylesheet" type="text/css" href="/site.css" />
<link rel="stylesheet" type="text/css" href="/controls/controls.css" />
<link rel="stylesheet" type="text/css" href="/demos/dateRangeCalendar/dateRangeCalendar.css" />
<link rel="stylesheet" type="text/css" href="/demos/kanjiCalendar/kanjiCalendar.css" />

<script type="text/javascript" src="/lib/jquery-1.8.2.min.js"></script>
<script type="text/javascript" src="/lib/globalize.js"></script>
<script type="text/javascript" src="/lib/globalize.culture.ar.js"></script>
<script type="text/javascript" src="/lib/globalize.culture.fr.js"></script>
<script type="text/javascript" src="/lib/globalize.culture.ja.js"></script>
<script type="text/javascript" src="/lib/globalize.culture.th.js"></script>
<script type="text/javascript" src="/release/quickui.js"></script>
<script type="text/javascript" src="/release/quickui.catalog.js"></script>
<script type="text/javascript" src="/controls/controls.js"></script>
<script type="text/javascript" src="/demos/dateRangeCalendar/dateRangeCalendar.js"></script>
<script type="text/javascript" src="/demos/kanjiCalendar/kanjiCalendar.js"></script>

<title>QuickUI web control framework</title>

<style>
h1 {
    margin-bottom: 1.5em;
}

/* This page is one where we want the browser title different from main heading. */
.SitePage_title {
    display: none;
}

.benefits {
    color: #928274;
    font-size: 24px;
}
.benefits b {
    color: #391C01;
}

.inlineDemos > *:not(:last-child) {
    margin-right: 1em;
}
</style>

<script type="text/javascript">
$( function() {
    var today = new Date();
    $( ".DateTextBox" ).control().date( new Date( today ) );
    var selectionStart = new Date( today );
    var selectionEnd = new Date( today );
    selectionEnd.setDate( selectionEnd.getDate() + 9 );
    $( ".DateRangeCalendar" ).control()
        .selectionStart( selectionStart )
        .selectionEnd( selectionEnd );
    $( "#buttonTutorial" ).click( function() {
        window.location = "/tutorial/";
    });
});
</script>

</head>

<body data-create-controls="true" data-control="SitePage">

<div data-property="navigationLinks">
    
    <p>
    <button data-control="SampleSpriteButton" id="buttonTutorial">Interactive Tutorial</button>
    </p>

    <h2 style="margin-top: 0;">Recent news</h2>
    <div
        data-control="BlogHeadlines"
        data-feed="http://blog.quickui.org/feed/"
        data-count="3"
    >
    </div>
    
    <h2>Control of the Week</h2>
    <div
        data-control="BlogHeadlines"
        data-feed="http://miksovsky.blogs.com/flowstate/controls/atom.xml"
        data-count="1"
    >
    </div>
    
</div>

<p class="benefits">
<b>Accelerate</b> •
<b>Organize</b> •
<b>Iterate</b> •
<b>Maintain</b> •
<b>Share</b>
your UI code
</p>

<p>
QuickUI is a free and open JavaScript framework that lets you create your web
app with user interface components called <i>controls</i>. A control includes
all the DOM elements, interactive behavior, and visual styling necessary for the
control to function. You can define a control to implement any level of your
app's UI: a page template, a region on the page, a special button, etc. This
approach lets you create great web applications with clean, intuitive,
responsive user interfaces that fit the task and are a joy to use.

With this approach, you can bring all the benefits of traditional object-
oriented design to bear on your JavaScript UI code.
</p>

<h2>Build up complex user interfaces from small building blocks</h2>
<p>
    Every web framework offers a date picker, but QuickUI packs a world of power
    into the one it gives you. Here's the typical example:
</p>
<div>
    <div data-control="DateComboBox">
        <div data-property="dropdownButtonContent">
            <!-- Custom icon; see notes at /catalog/DateComboBox -->
            <img ref="calendarIcon" src="/catalog/resources/calendar_alt_fill_16x16.png"/>
        </div>
    </div>
</div>
<p>
    (Whenever you're up for it, you can check out the docs and source for the
    above <a data-control="CatalogLink">DateComboBox</a> component, or any of
    the other components described here.) Under the covers, many pieces here
    that work together to make this date picker — and every one of those pieces
    of functionality is available to you as a component in its own right. The
    combo box behavior, for example:
</p>
<div><div data-control="ComboBox"></div></div>
<p>
    With that, you can make lots of other kinds of combo boxes, like a
    *** combo box for picking things from lists ***. In a date combo box,
    the text box portion needs to actually understand how to parse and
    represent dates, so that's offered as its own DateTextBox component:
</p>
<div><div data-control="DateTextBox"></div></div>
<p>
    And the popup portion of a date picker shows a calendar month that you
    can navigate through:
</p>
<div><div data-control="CalendarMonthNavigator"></div></div>
<p>
    The ability to navigate left and right between months is a general
    user interface pattern that crops up in lots of other situations — so
    of course that's delivered as a component as well:
</p>
<div><div data-control="SequenceNavigator"></div></div>
<p>
    In this case, you're navigate among months. The month itself is rendered
    using a component:
</p>
<div><div data-control="CalendarMonthWithHeadings"></div></div>
<p>
    And each piece of the month — the headings, the cells for the days, etc.,
    are all available as components, all of which you can use.
</p>
<p>
    Graph thumbnail and link to full graph. Better graph lines, legend.
</p>

<h2>Waaaay beyond styling</h2>
<p>
    Previous user interface frameworks only gave you big, chunky UI widgets to
    work with. Your ability to customize them is limited to the things the
    widget author could image you'd want to change. And while you can 
    customize thigns a bit, there's a limit to what's possible with CSS.
    QuickUI lets you go way beyond that limit, with components that can
    accept <i>other</i> components. Suppose you can have a product like, say,
    Flickr that wants to show interesting the most
    <a href="http://www.flickr.com/explore/interesting/">interesting</a> photo
    of the day on a calendar. Using the <a data-control="CatalogLink">CalendarDay</a>
    component as a starting point, create a new calendar-day-with-photo component:
</p>
<div><div data-control="FlickrInterestingDay"></div></div>
<p>
    Drop the above component into the <i>exact same</i> calendar month navigator
    component shown above, and voilà:
</p>
<div><div data-control="FlickrInterestingNavigator"></div></div>
<p>
    Or you could create a new day component that renders a date with both Roman
    numerals and kanji calligraphy:
</p>
<div><div data-control="KanjiCalendarDay" style="display: inline-block;"></div></div>
<p>
    And drop that into a calendar month for a result that's not possible with
    CSS alone:
</p>
<div><div data-control="KanjiCalendarMonth"></div></div>

<h2>Remixable user interface components</h2>
<p>
    Everyone's user interface needs are different. That's why all QuickUI
    components are designed to be remixed: composed with other components,
    extended with custom behavior, and generally adapted to the needs of
    your app. In the case of this calendar, you can tell the calendar
    to use a different component to render the days — and in that component,
    you can do whatever you want.
</p>
<p>
    And if you have more complex needs, you can easily recombine these
    elements to create, for example, a date <i>range</i> picker that picks
    both a start and end date in a single component:
</p>
<div><div data-control="DateRangeCalendar" data-count="3"></div></div>

<h2>Shared components encourage investment in fundamentals</h2>
<p>
    There are many reasons why building user interfaces this way makes a lot
    of sense. One is that reusable components permit heavier in investment
    in fundamentals. Take the complex chore of localizing a calendar to other
    languages. Here are some instances of the same calendar month component,
    only now they've been instructed to show a calendar appropriate to French,
    Japanese, Thai, or Arabic cultures:
</p>
<div class="inlineDemos">
    <div data-control="CalendarMonthWithHeadings" data-culture="fr"></div>
    <div data-control="CalendarMonthWithHeadings" data-culture="ja"></div>
    <div data-control="CalendarMonthWithHeadings" data-culture="th"></div>
    <div data-control="CalendarMonthWithHeadings" data-culture="ar"></div>
</div>
<p>
    Not only do the text labels for the month or days of the week change —
    different cultures prefer to see different days of the week as the "first"
    day of a week (Sunday in North American, Monday in Europe, Monday in Arabic
    cultures). And different cultures expect to see the different parts of a
    date rendered differently in a text box:
</p>
<div class="inlineDemos">
    <div data-control="DateTextBox" data-culture="fr"></div>
    <div data-control="DateTextBox" data-culture="ja"></div>
    <div data-control="DateTextBox" data-culture="th"></div>
    <div data-control="DateTextBox" data-culture="ar"></div>
</div>
<p>
    Few teams can afford to invest that kind of effort — but if everyone shares
    an implementation, then that kind of investment will produce returns for
    everyone. Other examples of investments the component approach makes more
    reasonable are: performance, keyboard support, general accessibility, 
    cutting-edge CSS optimization, and device responsiveness.
</p>

<p>
    These days, your web applications need to be <i>responsive</i> and
    adapt to the capabilities of the device and OS the user is running.
    It's easy to create QuickUI components that go far beyond what's possible
    with responsive CSS, and create components that use fundamentally
    different presentations based on the context. The following date picker
    uses a mobile OS' native date picker on a mobile device, but the date
    combo box above on a full browser:
</p>
<!-- <div><div data-control="ResponsiveDatePicker"></div></div> -->

<h2>Beaucoup benefits</h2>
<p>
***
</p>

<ol>
<li>Organize your UI code logically.</li>
<li>Start with well-tested UI building blocks.</li>
<li>Quickly iterate on the design of your app’s interface.</li>
<li>Share common UI solutions with your teammates and the web at large.</li>
</ol>

<h2>What makes QuickUI different from other web frameworks?</h2>

<ul>
<li>
<b>Composability</b>. This means you can generally put one control inside
another. When other frameworks offer, say, a date picker, it’s a solid,
immutable block; you can’t actually stick anything inside the date picker, so
your ability to customize the experience is limited to those customizations the
widget's author thought you'd want. Most QuickUI controls, in contrast, are
designed you can place one control inside another whenever that would make
sense.
</li>
<li>
<b>Modularity</b>. Good controls should only have local effects and
dependencies. When you add a control to a page, you don’t want to suddenly
discover that the control is inadvertently stomping on, say, CSS styles you’re
using elsewhere. Similarly, a control shouldn’t make lots of demands on its
container; you should be able to stick a control anywhere and get something
reasonable. In QuickUI, all controls are designed to be as context-independent
as possible. Moreover, the QuickUI framework ensures that your controls have
deterministic, reliable access to their own elements — your code won’t
accidentally pick up other elements on the page.
</li>
<li>
<b>Extensibility</b>. You can easily create specialized version of a control
class by subclassing it. This is a killer feature, because it lets you build new
components out of existing ones. QuickUI provides well-defined semantics for how
a subclass and its parent classes can work together to populate the DOM. Most
frameworks that let you create UI subclasses force you to wrap the elements of a
parent class, which turns out to be a dead end. In contrast, a QuickUI subclass
populates “slots” in its base class — and can define new slots of its own. For
more on this approach, see
<a data-control="Link" href="/docs/rendering.html">how controls
render themselves</a>.
</li>
<li>
<b>Opacity</b>. You can quickly define an external-facing API for your control
class, obviating the need or temptation for other developers to muck about
inside your control’s DOM. This keeps your control’s contract with its host
container clean and well-defined, allowing you to evolve your controls without
breaking everyone who’s already using them.
</li>
<li>
<b>Helpers for common UI situations</b>. QuickUI’s runtime has helper functions
to address situations that often come up when creating reusable controls, such
as controls that need to perform custom layout calculations when they're added
to the DOM, or when their size changes.
</li>
<li>
<b>Control classes are first-class objects</b>. QuickUI permits the creation of
meta-controls that can take another control class as input. For example, you can
tell a <a data-control="CatalogLink">ListBox</a> control which control class
should be used to represent its individual list items, and the ListBox will
automatically take care of creating or destroying instances of that item class
as the set of list items changes.
</li>
<li>
<b>Search engine support</b>. You want the best of both worlds: to create UI in
JavaScript <i>and</i> have UI text content searchable by Google and other search
engines. QuickUI lets you reference controls in searchable HTML and then
<a data-control="Link" href="/tutorial/rehydration.html">rehydrate</a>
those controls in the user’s browser. If you inspect this page's
<span data-control="Tag">body</span> tag, for example, you'll see how the site's
page template (which is implemented as a QuickUI control) is applied on the
client to what's otherwise plain, searchable HTML.
</li>
</ul>

<h2>A good citizen of the open web</h2>

<ul>
<li>
Built on top of <a data-control="Link" href="http://jquery.com">jQuery</a>,
the web’s most popular JavaScript library.
</li>
<li>
Works in all mainstream browsers: Apple Safari, Google Chrome, Microsoft
Internet Explorer 8+, and Mozilla Firefox. QuickUI leverages the browser as much
as possible. It uses native browser features when possible and, in older
browsers, can serve as a polyfill for HTML5 features. QuickUI is planned to
coevolve with the emerging HTML specification for web components.
</li>
<li>
Agnostic with regards to your back end, your data binding model, your
workflow, and your tool pipeline.
</li>
<li>
Free and open. The <a data-control="Link" href="https://github.com/JanMiksovsky/quickui">source code</a>
is open under the
<a data-control="Link" href="http://www.opensource.org/licenses/mit-license.php">MIT License</a>.
</li>
</ul>

<h2>A catalog of parts to start with</h2>
<p>
The optional <a data-control="Link" href="/catalog/">QuickUI Catalog</a> is
library of ~80 UI controls. Each control tries to do just one thing really well,
and these are intended as starting point for your own UI. Originally designed
for full browsers, many controls work on mobile browsers as well.
</p>
<p>
The page you are reading now, and this entire site, is built using QuickUI and
controls from the QuickUI Catalog.
</p>

<h2>Get started:</h2>
<ul>
<li>
Run through the <a data-control="Link" href="/tutorial/">interactive
tutorial</a>.
</li>
<li>
Browse the <a data-control="Link" href="/catalog/">QuickUI Catalog</a> of
controls.
</li>
<li>
Take a look at the <a data-control="Link" href="/docs/">framework
documentation</a>.
</li>
<li>
View the <a data-control="Link"
href="https://github.com/JanMiksovsky/quickui">source code</a> on GitHub.
</li>
</ul>

</body>

</html>
